package govex

import (
	"strconv"
	"strings"
	"time"

	"github.com/grokify/gocharts/v2/data/table"
	"github.com/grokify/mogo/text/markdown"
	"github.com/grokify/mogo/time/timeutil"
	"github.com/grokify/mogo/type/stringsutil"

	"github.com/grokify/govex/cve20"
	"github.com/grokify/govex/severity"
)

const (
	NameUnnamedVulerability = "Unnamed Vulnerability"
)

type Vulnerability struct {
	App                 string         `json:"app,omitempty"`
	ID                  string         `json:"id,omitempty"`
	Category            string         `json:"category,omitempty"`
	CVSS3Score          *float32       `json:"cvss3Score"`
	CVSS3Vector         string         `json:"cvss3Vector"`
	Description         string         `json:"description,omitempty"`
	DescriptionLang     string         `json:"descriptionLanguage,omitempty"`
	Fixed               bool           `json:"fixed,omitempty"`
	Library             Library        `json:"library"`
	Location            *Location      `json:"location,omitempty"`
	Metrics             cve20.Metrics  `json:"metrics,omitempty"`
	Name                string         `json:"name,omitempty"`
	References          markdown.Links `json:"references,omitempty"`
	ReferenceURL        string         `json:"referenceURL,omitempty"`
	Resolution          string         `json:"resolution,omitempty"`
	ResolutionTime      *time.Time     `json:"resolutionDate,omitempty"`
	Severity            string         `json:"severity,omitempty"`
	SLATimeStart        *time.Time     `json:"slaTimeStart,omitempty"`
	SLAStatus           string         `json:"slaStatus,omitempty"`
	SourceIdentifier    string         `json:"sourceIdentifier"`
	StartTime           *time.Time     `json:"startDate,omitempty"`
	Status              string         `json:"status,omitempty"`
	VersionEndExcluding string         `json:"versionEndExcluding,omitempty"`

	ProcSLAEvalTime time.Time
}

func (vn *Vulnerability) CVE() cve20.CVE {
	cv := cve20.CVE{
		ID:               vn.ID,
		SourceIdentifier: vn.SourceIdentifier,
		VulnStatus:       vn.Status,
	}
	if vn.Severity != "" {
		cv.AddMetric31(vn.SourceIdentifier, vn.Category, vn.Severity)
	}
	cv.Metrics.AppendMetrics(vn.Metrics)
	cv.AddConfiguration(vn.VersionEndExcluding)
	cv.AddDescription(vn.Name, vn.Description, vn.DescriptionLang, vn.App, vn.VersionEndExcluding)
	return cv
}

func (vn *Vulnerability) BuildSLAStatusString(slaMapDays SLAMap, slaEvalTime time.Time, unknownString string) string {
	vn.SLAStatus = slaMapDays.MustSLAStatusTimesString(vn.Severity, vn.StartTime, slaEvalTime, "")
	return vn.SLAStatus
}

func (vn *Vulnerability) StartTimeString(layout string, unsetTimeString string) string {
	if vn.StartTime == nil {
		return unsetTimeString
	} else {
		return vn.StartTime.Format(layout)
	}
}

func (vn *Vulnerability) AgeDays(evalTime time.Time, unknownDays int) int {
	if vn.StartTime == nil {
		return unknownDays
	} else {
		return int(timeutil.DurationDaysInt64(
			evalTime.Sub(*vn.StartTime),
		))
	}
}

func (vn *Vulnerability) InflateSeverity(sm severity.SeverityMap) error {
	if len(sm) > 0 &&
		vn.CVSS3Score != nil &&
		(strings.TrimSpace(vn.Severity) == "" || vn.Severity == severity.SeverityUnknown) {
		if sev, err := sm.SeverityFloat32(*vn.CVSS3Score); err != nil {
			return err
		} else {
			vn.Severity = sev
		}
	}
	return nil
}

const (
	FieldAcceptedTime        = "Accepted Time"
	FieldAcceptedTimeRFC3339 = "Start Date"
	FieldAgeDays             = "Age"
	FieldCategory            = "Category"
	FieldDescription         = "Description"
	FieldFixVersion          = "Fixed Version"
	FieldID                  = "ID"
	FieldLibraryName         = "Library"
	FieldLibraryVersion      = "Library Version"
	FieldLibraryVersionFixed = "Library Version Fixed"
	FieldLocationPath        = "Location"
	FieldLocationLineStart   = "Start Line"
	FieldLocationLineEnd     = "End Line"
	FieldName                = "Name"
	FieldNameAndDesc         = "Name+Desc"
	FieldNameWithURL         = "Name+URL"
	FieldReferenceURL        = "Reference URL"
	FieldReferences          = "References"
	FieldResolution          = "Resolution"
	FieldSeverity            = "Severity"
	FieldSLAOpenStatus       = "Open SLA Status"
	FieldStatus              = "Status"
)

type ValueOpts struct {
	SLAMap *SLAMap
}

func ParseField(field string) string {
	try := strings.TrimSpace(field)
	return try
}

func (vn *Vulnerability) Value(field, defaultValue string, opts *ValueOpts) string {
	field = ParseField(field)
	switch field {
	case FieldAcceptedTimeRFC3339:
		return vn.StartTimeString(time.RFC3339, defaultValue)
	case FieldAgeDays:
		age := strconv.Itoa(vn.AgeDays(vn.ProcSLAEvalTime, -1))
		if age == "-1" {
			return defaultValue
		} else {
			return age
		}
	case FieldCategory:
		return stringsutil.TrimSpaceOrDefault(vn.Category, defaultValue)
	case FieldDescription:
		return stringsutil.TrimSpaceOrDefault(vn.Description, defaultValue)
	case FieldFixVersion:
		return stringsutil.TrimSpaceOrDefault(vn.VersionEndExcluding, defaultValue)
	case FieldID:
		return stringsutil.TrimSpaceOrDefault(vn.ID, defaultValue)
	case FieldLibraryName:
		return stringsutil.TrimSpaceOrDefault(vn.Library.Name, defaultValue)
	case FieldLibraryVersion:
		return stringsutil.TrimSpaceOrDefault(vn.Library.Version, defaultValue)
	case FieldLibraryVersionFixed:
		return stringsutil.TrimSpaceOrDefault(vn.Library.VersionFixed, defaultValue)
	case FieldLocationPath:
		if vn.Location != nil {
			return stringsutil.TrimSpaceOrDefault(vn.Location.PathString(), defaultValue)
		} else {
			return defaultValue
		}
	case FieldLocationLineStart:
		if vn.Location != nil {
			return stringsutil.TrimSpaceOrDefault(vn.Location.LineStartString(), defaultValue)
		} else {
			return defaultValue
		}
	case FieldLocationLineEnd:
		if vn.Location != nil {
			return stringsutil.TrimSpaceOrDefault(vn.Location.LineEndString(), defaultValue)
		} else {
			return defaultValue
		}
	case FieldName:
		return stringsutil.TrimSpaceOrDefault(vn.Name, defaultValue)
	case FieldNameAndDesc:
		title := strings.TrimSpace(vn.Value(FieldName, "", nil))
		desc := strings.TrimSpace(vn.Value(FieldDescription, "", nil))
		var parts []string
		if title != "" {
			parts = append(parts, title)
		}
		if desc != "" {
			parts = append(parts, desc)
		}
		if len(parts) == 2 && stringsutil.ReverseIndex(parts[0], ".") != 0 {
			parts[0] += "."
		}
		return strings.Join(strings.Fields(strings.Join(parts, " ")), " ")
	case FieldNameWithURL:
		return markdown.Linkify(
			vn.Value(FieldReferenceURL, "", opts),
			vn.Value(FieldName, NameUnnamedVulerability, opts))
	case FieldReferences:
		refs := strings.Join(vn.References.Texts(true, true, true), " ")
		return stringsutil.TrimSpaceOrDefault(refs, defaultValue)
	case FieldReferenceURL:
		return stringsutil.TrimSpaceOrDefault(vn.ReferenceURL, defaultValue)
	case FieldResolution:
		return stringsutil.TrimSpaceOrDefault(vn.Resolution, defaultValue)
	case FieldSeverity:
		return stringsutil.TrimSpaceOrDefault(stringsutil.Capitalize(vn.Severity), defaultValue)
	case FieldSLAOpenStatus:
		if opts != nil && opts.SLAMap != nil {
			return vn.BuildSLAStatusString(*opts.SLAMap, vn.ProcSLAEvalTime, defaultValue)
		} else {
			return defaultValue
		}
	case FieldStatus:
		return stringsutil.TrimSpaceOrDefault(vn.Status, defaultValue)
	default:
		return defaultValue
	}
}

func (vn *Vulnerability) Values(colDefs table.ColumnDefinitions, opts *ValueOpts) []string {
	var s []string
	for _, cf := range colDefs {
		s = append(s, vn.Value(cf.SourceName, cf.DefaultValue, opts))
	}
	return s
}

func (vn *Vulnerability) ValuesStrings(fields []string, opts *ValueOpts) []string {
	var s []string
	for _, field := range fields {
		s = append(s, vn.Value(field, "", opts))
	}
	return s
}
