package govex

import (
	"strconv"
	"strings"
	"time"

	"github.com/grokify/gocharts/v2/data/table"
	"github.com/grokify/mogo/text/markdown"
	"github.com/grokify/mogo/time/duration"
	"github.com/grokify/mogo/time/timeutil"
	"github.com/grokify/mogo/type/stringsutil"

	"github.com/grokify/govex/cisakevc"
	"github.com/grokify/govex/cve20"
	"github.com/grokify/govex/severity"
)

const (
	NameUnnamedVulerability = "Unnamed Vulnerability"
)

type Vulnerability struct {
	App                      string         `json:"app,omitempty"`
	ID                       string         `json:"id,omitempty"`
	Category                 string         `json:"category,omitempty"`
	CVSS3Score               *float32       `json:"cvss3Score"`
	CVSS3Vector              string         `json:"cvss3Vector"`
	Description              string         `json:"description,omitempty"`
	DescriptionLang          string         `json:"descriptionLanguage,omitempty"`
	Fixed                    bool           `json:"fixed,omitempty"`
	Library                  Library        `json:"library"`
	Location                 *Location      `json:"location,omitempty"`
	Metrics                  cve20.Metrics  `json:"metrics,omitempty"`
	Module                   string         `json:"module,omitempty"`
	Name                     string         `json:"name,omitempty"`
	References               markdown.Links `json:"references,omitempty"`
	ReferenceURL             string         `json:"referenceURL,omitempty"`
	Reporters                Reporters      `json:"reporters,omitempty"`
	Resolution               string         `json:"resolution,omitempty"`
	ResolutionTime           *time.Time     `json:"resolutionDate,omitempty"`
	Severity                 string         `json:"severity,omitempty"`
	SLATimeStart             *time.Time     `json:"slaTimeStart,omitempty"`
	SLAStatus                string         `json:"slaStatus,omitempty"`
	SourceIdentifier         string         `json:"sourceIdentifier"`
	SourceComponent          string         `json:"sourceComponent"`
	StartTime                *time.Time     `json:"startDate,omitempty"`
	Status                   string         `json:"status,omitempty"`
	Tags                     []string       `json:"tags,omitempty"`
	VersionEndExcluding      string         `json:"versionEndExcluding,omitempty"`
	VersionRemediationTarget string         `json:"versionRemediationTarget,omitempty"`
	WorkItemID               *string        `json:"workItemID,omitempty"`
	WorkItemURL              *string        `json:"workItemURL,omitempty"`

	ProcSLAEvalTime time.Time
}

func (vn *Vulnerability) CVE() cve20.CVE {
	cv := cve20.CVE{
		ID:               vn.ID,
		SourceIdentifier: vn.SourceIdentifier,
		VulnStatus:       vn.Status,
	}
	if vn.Severity != "" {
		cv.AddMetric31(vn.SourceIdentifier, vn.Category, vn.Severity)
	}
	cv.Metrics.AppendMetrics(vn.Metrics)
	cv.AddConfiguration(vn.VersionEndExcluding)
	cv.AddDescription(vn.Name, vn.Description, vn.DescriptionLang, vn.App, vn.VersionEndExcluding)
	return cv
}

func (vn *Vulnerability) BuildSLAStatusString(slaPolicy severity.SLAPolicy, slaEvalTime time.Time, unknownString string) string {
	vn.SLAStatus = slaPolicy.MustSLAStatusTimesString(vn.Severity, vn.StartTime, slaEvalTime, "")
	return vn.SLAStatus
}

func (vn *Vulnerability) StartTimeString(layout string, unsetTimeString string) string {
	if vn.StartTime == nil {
		return unsetTimeString
	} else {
		return vn.StartTime.Format(layout)
	}
}

func (vn *Vulnerability) Age(evalTime time.Time, unknownDuration time.Duration) time.Duration {
	if vn.SLATimeStart == nil {
		return unknownDuration
	} else {
		return evalTime.Sub(*vn.SLATimeStart)
	}
}

func (vn *Vulnerability) AgeDays(evalTime time.Time, unknownDays int) int {
	if vn.StartTime == nil {
		return unknownDays
	} else {
		return int(duration.DurationDaysInt64(
			vn.Age(evalTime, time.Duration(unknownDays)*timeutil.Day),
		))
	}
}

func (vn *Vulnerability) InflateSeverity(sm severity.SeverityMapCVSS) error {
	if len(sm) > 0 &&
		vn.CVSS3Score != nil &&
		(strings.TrimSpace(vn.Severity) == "" || vn.Severity == severity.SeverityUnknown) {
		if sev, err := sm.SeverityFromScoreFloat32(*vn.CVSS3Score); err != nil {
			return err
		} else {
			vn.Severity = sev
		}
	}
	return nil
}

const (
	FieldAcceptedTime        = "Accepted Time"
	FieldAcceptedTimeRFC3339 = "Start Date"
	FieldAgeDays             = "Age"
	FieldCategory            = "Category"
	FieldDescription         = "Description"
	FieldFixVersion          = "Fixed Version"
	FieldID                  = "ID"
	FieldLibraryName         = "Library"
	FieldLibraryVersion      = "Library Version"
	FieldLibraryVersionFixed = "Library Version Fixed"
	FieldLocationPath        = "Location"
	FieldLocationLineStart   = "Location Start Line"
	FieldLocationLineEnd     = "Location End Line"
	FieldName                = "Name"
	FieldNameAndDesc         = "Name+Desc"
	FieldNameWithURL         = "Name+URL"
	FieldReferenceURL        = "Reference URL"
	FieldReferences          = "References"
	FieldResolution          = "Resolution"
	FieldSeverity            = "Severity"
	FieldSLAOpenStatus       = "Open SLA Status"
	FieldSourceComponent     = "Source Component"
	FieldStatus              = "Status"
)

type ValueOptions struct {
	CISAKEVC   *cisakevc.VulnerabilitySet
	DateFormat string
	SLAOptions *severity.SLAOptions
}

func ParseField(field string) string {
	try := strings.TrimSpace(field)
	return try
}

func (vn *Vulnerability) SLAElapsed(sla severity.SLAPolicy, compTime time.Time) bool {
	return vn.SLAOverdueDuration(sla, compTime) > 0
	/*
		if vn.SLATimeStart == nil || vn.SLATimeStart.IsZero() {
			return false
		}
		sev := strings.TrimSpace(vn.Severity)
		if sev == "" {
			return false
		}
		if slaDays, ok := slaMap[sev]; ok {
			ageDays := duration.DurationDays(compTime.Sub(*vn.SLATimeStart))
			if ageDays > float64(slaDays) {
				return true
			}
		}
		return false
	*/
}

func (vn *Vulnerability) SLAOverdueDuration(sla severity.SLAPolicy, compTime time.Time) time.Duration {
	if vn.SLATimeStart == nil || vn.SLATimeStart.IsZero() {
		return 0
	}
	sev := strings.TrimSpace(vn.Severity)
	if sev == "" {
		return 0
	}
	slaDays := sla.SeveritySLADays(sev)
	slaDuration := time.Duration(slaDays) * timeutil.Day
	ageDuration := compTime.Sub(*vn.SLATimeStart)
	if ageDuration > slaDuration {
		return ageDuration - slaDuration
	}
	return 0
}

func (vn *Vulnerability) SLACompliant(sla severity.SLAPolicy, slaRefTime time.Time) bool {
	if vn.SLATimeStart == nil || vn.SLATimeStart.IsZero() {
		return false
	}
	sev := strings.TrimSpace(vn.Severity)
	if sev == "" {
		return false
	}
	slaDays := sla.SeveritySLADays(sev)
	ageDays := duration.DurationDays(slaRefTime.Sub(*vn.SLATimeStart))
	return ageDays < float64(slaDays)
}

func (vn *Vulnerability) SLAInfo(slaMap severity.SLAMap, slaRefTime time.Time) (ageDays, overdueDays int, overdue bool) {
	ageDaysFloat64 := duration.DurationDays(slaRefTime.Sub(*vn.SLATimeStart))
	ageDays = int(ageDaysFloat64)

	if vn.SLATimeStart == nil || vn.SLATimeStart.IsZero() {
		return -1, -1, false
	}
	sev := strings.TrimSpace(vn.Severity)
	if sev == "" {
		return -1, -1, false
	}
	if slaDays, ok := slaMap[sev]; ok {
		if ageDaysFloat64 > float64(slaDays) {
			return ageDays, int(ageDaysFloat64 - float64(slaDays)), true
		} else {
			return ageDays, 0, false
		}
	}
	return ageDays, 0, false
}

func (vn *Vulnerability) Value(field, defaultValue string, opts *ValueOptions) string {
	field = ParseField(field)
	switch field {
	case FieldAcceptedTimeRFC3339:
		return vn.StartTimeString(time.RFC3339, defaultValue)
	case FieldAgeDays:
		age := strconv.Itoa(vn.AgeDays(vn.ProcSLAEvalTime, -1))
		if age == "-1" {
			return defaultValue
		} else {
			return age
		}
	case FieldCategory:
		return stringsutil.TrimSpaceOrDefault(vn.Category, defaultValue)
	case FieldDescription:
		return stringsutil.TrimSpaceOrDefault(vn.Description, defaultValue)
	case FieldFixVersion:
		return stringsutil.TrimSpaceOrDefault(vn.VersionEndExcluding, defaultValue)
	case FieldID:
		return stringsutil.TrimSpaceOrDefault(vn.ID, defaultValue)
	case FieldLibraryName:
		return stringsutil.TrimSpaceOrDefault(vn.Library.Name, defaultValue)
	case FieldLibraryVersion:
		return stringsutil.TrimSpaceOrDefault(vn.Library.Version, defaultValue)
	case FieldLibraryVersionFixed:
		return stringsutil.TrimSpaceOrDefault(vn.Library.VersionFixed, defaultValue)
	case FieldLocationPath:
		if vn.Location != nil {
			return stringsutil.TrimSpaceOrDefault(vn.Location.PathString(), defaultValue)
		} else {
			return defaultValue
		}
	case FieldLocationLineStart:
		if vn.Location != nil {
			return stringsutil.TrimSpaceOrDefault(vn.Location.LineStartString(), defaultValue)
		} else {
			return defaultValue
		}
	case FieldLocationLineEnd:
		if vn.Location != nil {
			return stringsutil.TrimSpaceOrDefault(vn.Location.LineEndString(), defaultValue)
		} else {
			return defaultValue
		}
	case FieldName:
		return stringsutil.TrimSpaceOrDefault(vn.Name, defaultValue)
	case FieldNameAndDesc:
		title := strings.TrimSpace(vn.Value(FieldName, "", nil))
		desc := strings.TrimSpace(vn.Value(FieldDescription, "", nil))
		var parts []string
		if title != "" {
			parts = append(parts, title)
		}
		if desc != "" {
			parts = append(parts, desc)
		}
		if len(parts) == 2 && stringsutil.ReverseIndex(parts[0], ".") != 0 {
			parts[0] += "."
		}
		return strings.Join(strings.Fields(strings.Join(parts, " ")), " ")
	case FieldNameWithURL:
		return markdown.Linkify(
			vn.Value(FieldReferenceURL, "", opts),
			vn.Value(FieldName, NameUnnamedVulerability, opts))
	case FieldReferences:
		refs := strings.Join(vn.References.Texts(true, true, true), " ")
		return stringsutil.TrimSpaceOrDefault(refs, defaultValue)
	case FieldReferenceURL:
		return stringsutil.TrimSpaceOrDefault(vn.ReferenceURL, defaultValue)
	case FieldResolution:
		return stringsutil.TrimSpaceOrDefault(vn.Resolution, defaultValue)
	case FieldSeverity:
		return stringsutil.TrimSpaceOrDefault(stringsutil.Capitalize(vn.Severity), defaultValue)
	case FieldSLAOpenStatus:
		if opts != nil && opts.SLAOptions != nil && opts.SLAOptions.SLAPolicy != nil {
			return vn.BuildSLAStatusString(*opts.SLAOptions.SLAPolicy, vn.ProcSLAEvalTime, defaultValue)
		} else {
			return defaultValue
		}
	case FieldSourceComponent:
		return stringsutil.TrimSpaceOrDefault(vn.SourceComponent, defaultValue)
	case FieldStatus:
		return stringsutil.TrimSpaceOrDefault(vn.Status, defaultValue)
	default:
		return defaultValue
	}
}

func (vn *Vulnerability) Values(colDefs table.ColumnDefinitions, opts *ValueOptions) []string {
	var s []string
	for _, cf := range colDefs {
		s = append(s, vn.Value(cf.SourceName, cf.DefaultValue, opts))
	}
	return s
}

func (vn *Vulnerability) ValuesStrings(fields []string, opts *ValueOptions) []string {
	var s []string
	for _, field := range fields {
		s = append(s, vn.Value(field, "", opts))
	}
	return s
}
